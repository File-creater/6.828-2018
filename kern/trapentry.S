/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>

#include <kern/picirq.h>


###################################################################
# exceptions/interrupts
###################################################################

/* TRAPHANDLER defines a globally-visible function for handling a trap.
 * It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 *
 * You shouldn't call a TRAPHANDLER function from C, but you may
 * need to _declare_ one in C (for instance, to get a function pointer
 * during IDT setup).  You can declare the function with
 *   void NAME();
 * where NAME is the argument passed to TRAPHANDLER.
 */
#define TRAPHANDLER(name, num)						\
	.globl name;		/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */		\
	.align 2;		/* align function definition */		\
	name:			/* function starts here */		\
	pushl $(num);							\
	jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushl $0;							\
	pushl $(num);							\
	jmp _alltraps

.text

/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */


TRAPHANDLER_NOEC(DivideZeroHandler, T_DIVIDE)
TRAPHANDLER_NOEC(DebugHandler, T_DEBUG)
TRAPHANDLER_NOEC(NMIHandler, T_NMI)
TRAPHANDLER_NOEC(BrkptHandler, T_BRKPT)
TRAPHANDLER_NOEC(OverflowHandler, T_OFLOW)
TRAPHANDLER_NOEC(BREHandler, T_BOUND)
TRAPHANDLER_NOEC(InvalidOpHandler, T_ILLOP)
TRAPHANDLER_NOEC(DNAHandler, T_DEVICE)
TRAPHANDLER(DFHandler, T_DBLFLT)
/* #define T_COPROC  9  reserved (not generated by recent processors)  */
TRAPHANDLER(InvalidTssHandler, T_TSS)
TRAPHANDLER(SegNPHandler, T_SEGNP)
TRAPHANDLER(StackHandler, T_STACK)
TRAPHANDLER(GPHandler, T_GPFLT)
TRAPHANDLER(PFHandler, T_PGFLT)
/* #define T_RES    15   reserved */
TRAPHANDLER_NOEC(FEHandler, T_FPERR)
TRAPHANDLER(AlignHandler, T_ALIGN)
TRAPHANDLER_NOEC(MachineHandler, T_MCHK)
TRAPHANDLER_NOEC(SimderrHandler, T_SIMDERR)

TRAPHANDLER_NOEC(SystemCallHandler, T_SYSCALL)


TRAPHANDLER_NOEC(IRQsHandler0, IRQ_OFFSET+IRQ_TIMER)
TRAPHANDLER_NOEC(IRQsHandler1, IRQ_OFFSET+IRQ_KBD)
TRAPHANDLER_NOEC(IRQsHandler2, IRQ_OFFSET+2)
TRAPHANDLER_NOEC(IRQsHandler3, IRQ_OFFSET+3)
TRAPHANDLER_NOEC(IRQsHandler4, IRQ_OFFSET+IRQ_SERIAL)
TRAPHANDLER_NOEC(IRQsHandler5, IRQ_OFFSET+5)
TRAPHANDLER_NOEC(IRQsHandler6, IRQ_OFFSET+6)
TRAPHANDLER_NOEC(IRQsHandler7, IRQ_OFFSET+IRQ_SPURIOUS)
TRAPHANDLER_NOEC(IRQsHandler8, IRQ_OFFSET+8)
TRAPHANDLER_NOEC(IRQsHandler9, IRQ_OFFSET+9)
TRAPHANDLER_NOEC(IRQsHandler10, IRQ_OFFSET+10)
TRAPHANDLER_NOEC(IRQsHandler11, IRQ_OFFSET+11)
TRAPHANDLER_NOEC(IRQsHandler12, IRQ_OFFSET+12)
TRAPHANDLER_NOEC(IRQsHandler13, IRQ_OFFSET+13)
TRAPHANDLER_NOEC(IRQsHandler14, IRQ_OFFSET+IRQ_IDE)
TRAPHANDLER_NOEC(IRQsHandler15, IRQ_OFFSET+15)
# TRAPHANDLER_NOEC(IRQsHandler16, IRQ_OFFSET+16)
# TRAPHANDLER_NOEC(IRQsHandler17, IRQ_OFFSET+17)
# TRAPHANDLER_NOEC(IRQsHandler18, IRQ_OFFSET+18)
TRAPHANDLER_NOEC(IRQsHandler19, IRQ_OFFSET+IRQ_ERROR)

/*
 * Lab 3: Your code here for _alltraps
 */

// 根据Trapframe的结构，在压完tf_trapno（也就是num）之后，
// 我们还需要完成Trapframe中 tf_trapno上面四个变量的压栈，根据空间分别，倒过来压栈
// 然后利用ax寄存器将GD_KD传入ds和ex寄存器，然后将Trapframe的指针esp压栈，调用trap
_alltraps:
    pushw $0
    pushw %ds
    pushw $0
    pushw %es
    pushal
    movw $GD_KD, %ax
    movw %ax, %ds
    movw %ax, %es
    pushl %esp
    call trap
